var documenterSearchIndex = {"docs":
[{"location":"#SparseKmeansFeatureRanking.jl","page":"Home","title":"SparseKmeansFeatureRanking.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Sparse K-means via Feature Ranking","category":"page"},{"location":"","page":"Home","title":"Home","text":"This software package contains an efficient multi-threaded implementation of sparse K-means via feature ranking proposed by Zhang, Lange, and Xu (2020). The code is based on the original github repository. The authors of the original code have kindly agreed to redistribute the derivative of their code on this repository under the MIT License. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package requires Julia v1.6 or later, which can be obtained from https://julialang.org/downloads/ or by building Julia from the sources in the https://github.com/JuliaLang/julia repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package can be installed by running the following code:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\npkg\"add https://github.com/kose-y/SparseKmeansFeatureRanking.jl\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"For running the examples below, the following are also necessary. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg\"add Random Clustering SnpArrays\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"versioninfo()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia Version 1.7.1\nCommit ac5cc99908 (2021-12-22 19:35 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin19.5.0)\n  CPU: Intel(R) Core(TM) i7-7820HQ CPU @ 2.90GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-12.0.1 (ORCJIT, skylake)","category":"page"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First, let us initialize the random number generator for reproducibility. We use MersenneTwister to obtain the same result with different number of threads.","category":"page"},{"location":"","page":"Home","title":"Home","text":"!!! Since Julia 1.7, the default random number generator depends on thread launches.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Random, SparseKmeansFeatureRanking\nrng = MersenneTwister(7542)","category":"page"},{"location":"","page":"Home","title":"Home","text":"MersenneTwister(7542)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, we generate a random data with 300 samples and 100 features. For the first 33 features, we add 1.0 to samples 101:200 and 2.0 to samples 201:300 to give a cluster structure. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(features, cases) = (100, 300);\n(classes, sparsity)  = (3, 33);\nX = randn(features, cases);\n(m, n) = (div(features, 3), 2 * div(features, 3));\n(r, s) = (div(cases, 3) + 1, 2 * div(cases, 3));\nX[1:m, r:s] = X[1:m, r:s] .+ 1.0;\nX[1:m, s + 1:end] = X[1:m, s + 1:end] .+ 2.0;","category":"page"},{"location":"","page":"Home","title":"Home","text":"ImputedMatrix is the basic data structure for the SKFR algorithm with k-POD imputation. This can be generated using the function get_imputed_matrix(). The second argument 3 is the number of clusters, and the optional keyword argument rng determines the status of the random number generator to be used. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"IM = SparseKmeansFeatureRanking.get_imputed_matrix(collect(transpose(X)), 3; rng=rng);","category":"page"},{"location":"","page":"Home","title":"Home","text":"The function sparsekmeans1() selects sparsity most informative features globally. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(classout1, center1, selectedvec1, WSSval1, TSSval1) = SparseKmeansFeatureRanking.sparsekmeans1(IM, sparsity);","category":"page"},{"location":"","page":"Home","title":"Home","text":"classout1 is the class labels, center1 contains cluster centers, selectedvec1 contains selected informative features. WSSval1 shows within-cluster sum of squares value, and TSSval1 contains total sum of squares. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Clustering\nrandindex(classout1,[repeat([1], 100); repeat([2], 100); repeat([3], 100)])[1]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Checking the rand index gives the value 1.0, meaning perfect clustering. As expected, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"all(sort(selectedvec1).== 1:33)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also, the first 33 features are selected, as expected. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The function sparsekmeans2() selects sparsity most informative feature for each cluster. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"IM = SparseKmeansFeatureRanking.get_imputed_matrix(collect(transpose(X)), 3; rng=rng)\n(classout2, center2, selectedvec2, WSSval2, TSSval2) = SparseKmeansFeatureRanking.sparsekmeans2(IM, sparsity);","category":"page"},{"location":"","page":"Home","title":"Home","text":"randindex(classout2,[repeat([1], 100); repeat([2], 100); repeat([3], 100)])[1]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Selected feature does not necessarily match 1:33 for all the clusters, as seen below. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"selectedvec2","category":"page"},{"location":"#Matrices-with-missing-entries","page":"Home","title":"Matrices with missing entries","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We can apply the SKFR algorithm on the dataset with missing values, denoted by NaNs. Below, we put 10% of the values in the data matrix as NaN. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using StatsBase\nmissingix=sample(1:features*cases,Int(features*cases*0.1),replace=false)\nX_missing = deepcopy(X)\nX_missing[CartesianIndices(X_missing)[missingix]] .= NaN;","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, we run the SKFR functions just as above. For each iteration, missing values are imputed by the center of current cluster centers, as suggested by the k-POD imputation method. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"IM = SparseKmeansFeatureRanking.get_imputed_matrix(collect(transpose(X_missing)), 3; rng=rng);","category":"page"},{"location":"","page":"Home","title":"Home","text":"(classout1, center1, selectedvec1, WSSval1, TSSval1) = SparseKmeansFeatureRanking.sparsekmeans1(IM, sparsity);","category":"page"},{"location":"","page":"Home","title":"Home","text":"If we check the rand index, we see that the clustering result is a little bit noisy, as one may expect.","category":"page"},{"location":"","page":"Home","title":"Home","text":"randindex(classout1,[repeat([1], 100); repeat([2], 100); repeat([3], 100)])[1]","category":"page"},{"location":"","page":"Home","title":"Home","text":"The set of selected features is still the same as before. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"length(union(selectedvec1, 1:33))","category":"page"},{"location":"#SnpArray-Usage","page":"Home","title":"SnpArray Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The SKFR algorithm can also be applied to the PLINK 1 BED-formatted data through SnpArrays.jl. This can be considered a case of unsupervised ancestry informative marker (AIM) selection. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SnpArrays\nX = SnpArray(SnpArrays.datadir(\"EUR_subset.bed\"))\nnclusters = 3;","category":"page"},{"location":"","page":"Home","title":"Home","text":"IM = SparseKmeansFeatureRanking.get_imputed_matrix(X, nclusters; rng=rng)\n(classout, center, selectedvec, WSSval, TSSval) = SparseKmeansFeatureRanking.sparsekmeans1(IM, 1000);","category":"page"}]
}
